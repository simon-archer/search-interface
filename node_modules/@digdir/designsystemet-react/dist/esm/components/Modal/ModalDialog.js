'use client';
import { jsx, Fragment } from 'react/jsx-runtime';
import { useFloating, useMergeRefs, FloatingFocusManager } from '../../node_modules/@floating-ui/react/dist/floating-ui.react.js';
import { forwardRef, useRef, useContext, useEffect } from 'react';
import { Slot as $5e63c961fc1ce211$export$8c6ed5c666ac1360 } from '../../node_modules/@radix-ui/react-slot/dist/index.js';
import { clsx } from '../../node_modules/clsx/dist/lite.js';
import { useScrollLock } from './useScrollLock.js';
import { useModalState } from './useModalState.js';
import { ModalContext } from './ModalRoot.js';

const ModalDialog = forwardRef(({ onInteractOutside, onClose, onBeforeClose, asChild, className, children, ...rest }, ref) => {
    const Component = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : 'dialog';
    // This local ref is used to make sure the modal works without a ModalRoot
    const modalDialogRef = useRef(null);
    const { context } = useFloating();
    const modal = useContext(ModalContext);
    const open = useModalState(modalDialogRef);
    const { modalRef, setOpen } = modal;
    modal.closeModal = () => {
        if (onBeforeClose && onBeforeClose() === false)
            return;
        modalDialogRef.current?.close();
    };
    const mergedRefs = useMergeRefs([modalRef, ref, modalDialogRef]);
    useScrollLock(modalDialogRef, 'fds-modal--lock-scroll');
    useEffect(() => {
        setOpen(open);
    }, [open, setOpen]);
    useEffect(() => {
        const modalEl = modalRef.current;
        const handleBackdropClick = (e) => {
            if (e.target === modalEl && onInteractOutside) {
                // Fix bug where if you select text spanning two divs it thinks you clicked outside
                if (window.getSelection()?.toString())
                    return;
                onInteractOutside?.();
            }
        };
        if (modalEl)
            modalEl.addEventListener('click', handleBackdropClick);
        return () => {
            if (modalEl) {
                modalEl.removeEventListener('click', handleBackdropClick);
            }
        };
    }, [onInteractOutside, modalRef, onBeforeClose, ref]);
    useEffect(() => {
        const modalEl = modalRef.current;
        const handleModalClose = () => {
            onClose?.();
        };
        if (modalEl)
            modalEl.addEventListener('close', handleModalClose);
        return () => {
            if (modalEl) {
                modalEl.removeEventListener('close', handleModalClose);
            }
        };
    }, [modalRef, onClose]);
    const onCancel = (e) => {
        if (onBeforeClose && onBeforeClose() === false) {
            e.preventDefault();
            return;
        }
        modalRef.current?.close();
    };
    return (jsx(Component, { ref: mergedRefs, className: clsx('fds-modal', className), onCancel: onCancel, ...rest, children: open && (jsx(FloatingFocusManager, { context: context, children: jsx(Fragment, { children: children }) })) }));
});
ModalDialog.displayName = 'ModalDialog';

export { ModalDialog };
