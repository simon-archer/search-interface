'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var lite = require('../../node_modules/clsx/dist/lite.js');
var floatingUi_react = require('../../node_modules/@floating-ui/react/dist/floating-ui.react.js');
var floatingUi_dom = require('../../node_modules/@floating-ui/dom/dist/floating-ui.dom.js');
var floatingUi_core = require('../../node_modules/@floating-ui/core/dist/floating-ui.core.js');
var floatingUi_reactDom = require('../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const ARROW_HEIGHT = 7;
const ARROW_GAP = 4;
const Tooltip = React.forwardRef(({ children, content, placement = 'top', delay = 150, open: userOpen, defaultOpen = false, portal = true, inverted, className, style, ...rest }, ref) => {
    const [isOpen, setIsOpen] = React.useState(defaultOpen);
    const Container = portal ? floatingUi_react.FloatingPortal : React__namespace.Fragment;
    const arrowRef = React__namespace.useRef(null);
    const internalOpen = userOpen ?? isOpen;
    const { refs, floatingStyles, context } = floatingUi_react.useFloating({
        open: internalOpen,
        onOpenChange: setIsOpen,
        placement,
        whileElementsMounted: floatingUi_dom.autoUpdate,
        middleware: [
            floatingUi_core.offset(ARROW_HEIGHT + ARROW_GAP),
            floatingUi_dom.flip({
                fallbackAxisSideDirection: 'start',
            }),
            floatingUi_dom.shift(),
            floatingUi_reactDom.arrow({
                element: arrowRef,
            }),
        ],
    });
    const { styles: animationStyles } = floatingUi_react.useTransitionStyles(context, {
        initial: {
            opacity: 0,
        },
    });
    const { getReferenceProps, getFloatingProps } = floatingUi_react.useInteractions([
        // Event listeners to change the open state
        floatingUi_react.useHover(context, { move: false, delay }),
        floatingUi_react.useFocus(context),
        floatingUi_react.useDismiss(context),
        floatingUi_react.useRole(context, { role: 'tooltip' }),
    ]);
    const mergedRef = floatingUi_react.useMergeRefs([ref, refs.setFloating]);
    const childMergedRef = floatingUi_react.useMergeRefs([
        children
            .ref,
        refs.setReference,
    ]);
    if (!children ||
        children?.type === React__namespace.Fragment ||
        children === React__namespace.Fragment) {
        console.error('<Tooltip> children needs to be a single ReactElement and not: <React.Fragment/> | <></>');
        return null;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [React.cloneElement(children, getReferenceProps({
                ref: childMergedRef,
            })), internalOpen && (jsxRuntime.jsx(Container, { children: jsxRuntime.jsxs("div", { ref: refs.setFloating, style: { ...floatingStyles, ...animationStyles, ...style }, role: 'tooltip', ...getFloatingProps({
                        className: lite.clsx('fds-tooltip', inverted && 'fds-tooltip--inverted', className),
                        ref: mergedRef,
                        ...rest,
                    }), children: [content, jsxRuntime.jsx(floatingUi_react.FloatingArrow, { ref: arrowRef, context: context, className: 'fds-tooltip__arrow', height: ARROW_HEIGHT })] }) }))] }));
});
Tooltip.displayName = 'Tooltip';

exports.Tooltip = Tooltip;
