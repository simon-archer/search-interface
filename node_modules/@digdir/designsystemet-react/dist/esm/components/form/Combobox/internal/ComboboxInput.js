'use client';
import { jsxs, jsx } from 'react/jsx-runtime';
import { useContext } from 'react';
import { clsx } from '../../../../node_modules/clsx/dist/lite.js';
import { ChevronUpIcon, ChevronDownIcon } from '@navikt/aksel-icons';
import { useMergeRefs } from '../../../../node_modules/@floating-ui/react/dist/floating-ui.react.js';
import { ComboboxContext } from '../ComboboxContext.js';
import { useComboboxIdDispatch } from '../ComboboxIdContext.js';
import { prefix } from '../useCombobox.js';
import ComboboxChips from './ComboboxChips.js';
import ComboboxClearButton from './ComboboxClearButton.js';
import { Box } from '../../../Box/Box.js';
import { omit } from '../../../../utilities/objectUtils.js';

const ComboboxInput = ({ hideClearButton, listId, error, hideChips, handleKeyDown, ...rest }) => {
    const context = useContext(ComboboxContext);
    const idDispatch = useComboboxIdDispatch();
    if (!context) {
        throw new Error('ComboboxContext is missing');
    }
    const setActiveIndex = (id) => {
        idDispatch?.({ type: 'SET_ACTIVE_INDEX', payload: id });
    };
    const { forwareddRef, readOnly, disabled, open, inputRef, refs, inputValue, multiple, selectedOptions, formFieldProps, htmlSize, options, setOpen, getReferenceProps, setInputValue, handleSelectOption, } = context;
    const mergedRefs = useMergeRefs([forwareddRef, inputRef]);
    // onChange function for the input
    const onChange = (event) => {
        const value = event.target.value;
        setInputValue(value);
        setActiveIndex(0);
        // check if input value is the same as a label, if so, select it
        const option = options[prefix(value.toLowerCase())];
        if (!option)
            return;
        if (selectedOptions[prefix(option.value)])
            return;
        handleSelectOption({ option: option });
    };
    const showClearButton = multiple && !hideClearButton && Object.keys(selectedOptions).length > 0;
    /* Props from floating-ui */
    const props = getReferenceProps({
        ref: refs?.setReference,
        role: null,
        'aria-controls': null,
        'aria-expanded': null,
        'aria-haspopup': null,
        /* If we click the wrapper, open the list, set index to first option, and focus the input */
        onClick() {
            if (disabled)
                return;
            if (readOnly)
                return;
            setOpen(true);
            setActiveIndex(0);
            inputRef.current?.focus();
        },
        /* Handles list navigation */
        onKeyDown: handleKeyDown,
        // preventDefault on keydown to avoid sending in form
        onKeyPress(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
            }
        },
    });
    return (jsxs(Box, { ...props, "aria-disabled": disabled, className: clsx('fds-textfield__input', 'fds-combobox__input__wrapper', readOnly && 'fds-combobox--readonly', error && 'fds-combobox--error'), children: [jsxs("div", { className: 'fds-combobox__chip-and-input', children: [multiple && !hideChips && jsx(ComboboxChips, {}), jsx("input", { ref: mergedRefs, "aria-activedescendant": props['aria-activedescendant'], readOnly: readOnly, "aria-autocomplete": 'list', role: 'combobox', "aria-expanded": open, "aria-controls": open ? listId : undefined, autoComplete: 'off', size: htmlSize, value: inputValue, ...omit(['style', 'className'], rest), ...formFieldProps.inputProps, className: 'fds-combobox__input', onChange: (e) => {
                            onChange(e);
                            !open && setOpen(true);
                            rest.onChange && rest.onChange(e);
                        } })] }), showClearButton && jsx(ComboboxClearButton, {}), jsx("div", { className: 'fds-combobox__arrow', children: open ? (jsx(ChevronUpIcon, { title: 'arrow up', fontSize: '1.5em' })) : (jsx(ChevronDownIcon, { title: 'arrow down', fontSize: '1.5em' })) })] }));
};
ComboboxInput.displayName = 'ComboboxInput';
var ComboboxInput$1 = ComboboxInput;

export { ComboboxInput, ComboboxInput$1 as default };
