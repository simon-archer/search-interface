'use client';
import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import { forwardRef, useRef, useState, useEffect } from 'react';
import { FloatingPortal, FloatingFocusManager } from '../../../node_modules/@floating-ui/react/dist/floating-ui.react.js';
import { clsx } from '../../../node_modules/clsx/dist/lite.js';
import { useVirtualizer } from '../../../node_modules/@tanstack/react-virtual/dist/esm/index.js';
import { useFormField } from '../useFormField.js';
import useDebounce from '../../../utilities/useDebounce.js';
import { getSize } from '../../../utilities/getSize.js';
import useCombobox, { prefix, removePrefix } from './useCombobox.js';
import ComboboxInput from './internal/ComboboxInput.js';
import ComboboxLabel from './internal/ComboboxLabel.js';
import ComboboxError from './internal/ComboboxError.js';
import ComboboxNative from './internal/ComboboxNative.js';
import ComboboxCustom from './Custom.js';
import { useFloatingCombobox } from './useFloatingCombobox.js';
import { useComboboxKeyboard } from './useComboboxKeyboard.js';
import { ComboboxIdProvider } from './ComboboxIdContext.js';
import { ComboboxContext } from './ComboboxContext.js';
import { Box } from '../../Box/Box.js';
import { Spinner } from '../../Spinner/Spinner.js';
import { omit } from '../../../utilities/objectUtils.js';

const ComboboxComponent = forwardRef(({ value, initialValue = [], onValueChange, label, hideLabel = false, description, multiple = false, disabled = false, readOnly = false, hideChips = false, clearButtonLabel = 'Fjern alt', hideClearButton = false, error, errorId, id, name, portal = true, htmlSize = 0, virtual = false, children, style, loading, loadingLabel = 'Laster...', filter, chipSrLabel = (option) => 'Slett ' + option.label, className, ...rest }, forwareddRef) => {
    const size = getSize(rest.size || 'md');
    const inputRef = useRef(null);
    const portalRef = useRef(null);
    const listRef = useRef([]);
    const [inputValue, setInputValue] = useState(rest.inputValue || '');
    const { selectedOptions, options, restChildren, interactiveChildren, customIds, filteredOptionsChildren, filteredOptions, setSelectedOptions, } = useCombobox({
        children,
        inputValue,
        filter,
        multiple,
        initialValue,
    });
    const { open, setOpen, refs, floatingStyles, context, getReferenceProps, getFloatingProps, getItemProps, } = useFloatingCombobox({
        listRef,
    });
    const formFieldProps = useFormField({
        disabled,
        readOnly,
        error,
        errorId,
        size,
        description,
        id,
    }, 'combobox');
    // if value is set, set input value to the label of the value
    useEffect(() => {
        if (value && value.length > 0 && !multiple) {
            const option = options[prefix(value[0])];
            setInputValue(option?.label || '');
        }
    }, [multiple, value, options]);
    useEffect(() => {
        if (value && Object.keys(options).length >= 0) {
            const updatedSelectedOptions = value.map((option) => {
                const value = options[prefix(option)];
                return value;
            });
            setSelectedOptions(updatedSelectedOptions.reduce((acc, value) => {
                acc[prefix(value.value)] = value;
                return acc;
            }, {}));
        }
    }, [multiple, value, options, setSelectedOptions]);
    // handle click on option, either select or deselect - Handles single or multiple
    const handleSelectOption = (args) => {
        const { option, clear, remove } = args;
        if (clear) {
            setSelectedOptions({});
            setInputValue('');
            onValueChange?.([]);
            return;
        }
        if (!option)
            return;
        if (remove) {
            const newSelectedOptions = { ...selectedOptions };
            delete newSelectedOptions[prefix(option.value)];
            setSelectedOptions(newSelectedOptions);
            onValueChange?.(Object.keys(newSelectedOptions).map((key) => removePrefix(key)));
            return;
        }
        const newSelectedOptions = { ...selectedOptions };
        if (multiple) {
            if (newSelectedOptions[prefix(option.value)]) {
                delete newSelectedOptions[prefix(option.value)];
            }
            else {
                newSelectedOptions[prefix(option.value)] = option;
            }
            setInputValue('');
            inputRef.current?.focus();
        }
        else {
            /* clear newSelectedOptions */
            Object.keys(newSelectedOptions).forEach((key) => {
                delete newSelectedOptions[key];
            });
            newSelectedOptions[prefix(option.value)] = option;
            setInputValue(option?.label || '');
            // move cursor to the end of the input
            setTimeout(() => {
                inputRef.current?.setSelectionRange(option?.label?.length || 0, option?.label?.length || 0);
            }, 0);
        }
        setSelectedOptions(newSelectedOptions);
        onValueChange?.(Object.keys(newSelectedOptions).map((key) => removePrefix(key)));
        !multiple && setOpen(false);
        refs.domReference.current?.focus();
    };
    const debouncedHandleSelectOption = useDebounce(handleSelectOption, 50);
    const handleKeyDown = useComboboxKeyboard({
        filteredOptions,
        selectedOptions,
        readOnly: formFieldProps.readOnly || false,
        disabled: disabled,
        multiple,
        inputValue,
        options,
        open,
        interactiveChildren,
        setOpen,
        setInputValue,
        handleSelectOption: debouncedHandleSelectOption,
    });
    const rowVirtualizer = useVirtualizer({
        count: Object.keys(filteredOptionsChildren).length,
        getScrollElement: () => (virtual ? refs.floating.current : null),
        estimateSize: () => 70,
        measureElement: (elem) => {
            return elem.getBoundingClientRect().height;
        },
        overscan: 7,
    });
    return (jsxs(ComboboxContext.Provider, { value: {
            size,
            options,
            selectedOptions,
            multiple,
            disabled,
            readOnly,
            open,
            inputRef,
            refs,
            inputValue,
            formFieldProps,
            htmlSize,
            clearButtonLabel,
            customIds,
            filteredOptions,
            setInputValue,
            setOpen,
            getReferenceProps,
            getItemProps,
            /* Recieves the value of the option, and searches for it in our values lookup */
            onOptionClick: (value) => {
                if (readOnly)
                    return;
                if (disabled)
                    return;
                const option = options[prefix(value)];
                debouncedHandleSelectOption({ option: option });
            },
            handleSelectOption: debouncedHandleSelectOption,
            chipSrLabel,
            listRef,
            forwareddRef,
        }, children: [jsxs(Box, { className: clsx('fds-combobox', `fds-combobox--${size}`, disabled && 'fds-combobox__disabled', className), style: style, ref: portalRef, children: [name && (jsx(ComboboxNative, { name: name, selectedOptions: selectedOptions, multiple: multiple })), jsx(ComboboxLabel, { label: label, description: description, size: size, readOnly: readOnly, hideLabel: hideLabel, formFieldProps: formFieldProps }), jsx(ComboboxInput, { ...omit(['inputValue'], rest), hideClearButton: hideClearButton, listId: context.floatingId, error: error, hideChips: hideChips, handleKeyDown: handleKeyDown, "aria-busy": loading }), jsx(ComboboxError, { size: size, error: error, formFieldProps: formFieldProps })] }), open && (jsx(FloatingPortal, { root: portal ? null : portalRef, children: jsx(FloatingFocusManager, { context: context, initialFocus: -1, visuallyHiddenDismiss: true, children: jsxs(Box, { shadow: 'md', borderRadius: 'md', borderColor: 'default', "aria-labelledby": formFieldProps.inputProps.id, "aria-autocomplete": 'list', tabIndex: -1, ...getFloatingProps({
                            ref: refs.setFloating,
                            style: {
                                ...floatingStyles,
                            },
                        }), className: clsx('fds-combobox__options-wrapper', `fds-combobox--${size}`), children: [virtual && (jsx("div", { style: {
                                    height: `${rowVirtualizer.getTotalSize()}px`,
                                    width: '100%',
                                    position: 'relative',
                                }, children: rowVirtualizer.getVirtualItems().map((virtualRow) => (jsx("div", { ref: rowVirtualizer.measureElement, "data-index": virtualRow.index, style: {
                                        position: 'absolute',
                                        top: 0,
                                        left: 0,
                                        width: '100%',
                                        transform: `translateY(${virtualRow.start}px)`,
                                    }, children: filteredOptionsChildren[virtualRow.index] }, virtualRow.index))) })), loading ? (jsxs(ComboboxCustom, { className: 'fds-combobox__loading', children: [jsx(Spinner, { title: 'Laster', size: 'sm' }), loadingLabel] })) : (jsxs(Fragment, { children: [restChildren, !virtual && filteredOptionsChildren] }))] }) }) }))] }));
});
const Combobox = forwardRef((props, ref) => (jsx(ComboboxIdProvider, { children: jsx(ComboboxComponent, { ...props, ref: ref }) })));
Combobox.displayName = 'Combobox';

export { Combobox, ComboboxComponent };
