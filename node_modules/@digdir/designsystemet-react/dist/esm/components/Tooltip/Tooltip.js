'use client';
import { jsxs, Fragment, jsx } from 'react/jsx-runtime';
import * as React from 'react';
import { forwardRef, useState, cloneElement } from 'react';
import { clsx } from '../../node_modules/clsx/dist/lite.js';
import { useFloating, useTransitionStyles, useInteractions, useHover, useFocus, useDismiss, useRole, useMergeRefs, FloatingArrow, FloatingPortal } from '../../node_modules/@floating-ui/react/dist/floating-ui.react.js';
import { autoUpdate, flip, shift } from '../../node_modules/@floating-ui/dom/dist/floating-ui.dom.js';
import { offset } from '../../node_modules/@floating-ui/core/dist/floating-ui.core.js';
import { arrow } from '../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.js';

const ARROW_HEIGHT = 7;
const ARROW_GAP = 4;
const Tooltip = forwardRef(({ children, content, placement = 'top', delay = 150, open: userOpen, defaultOpen = false, portal = true, inverted, className, style, ...rest }, ref) => {
    const [isOpen, setIsOpen] = useState(defaultOpen);
    const Container = portal ? FloatingPortal : React.Fragment;
    const arrowRef = React.useRef(null);
    const internalOpen = userOpen ?? isOpen;
    const { refs, floatingStyles, context } = useFloating({
        open: internalOpen,
        onOpenChange: setIsOpen,
        placement,
        whileElementsMounted: autoUpdate,
        middleware: [
            offset(ARROW_HEIGHT + ARROW_GAP),
            flip({
                fallbackAxisSideDirection: 'start',
            }),
            shift(),
            arrow({
                element: arrowRef,
            }),
        ],
    });
    const { styles: animationStyles } = useTransitionStyles(context, {
        initial: {
            opacity: 0,
        },
    });
    const { getReferenceProps, getFloatingProps } = useInteractions([
        // Event listeners to change the open state
        useHover(context, { move: false, delay }),
        useFocus(context),
        useDismiss(context),
        useRole(context, { role: 'tooltip' }),
    ]);
    const mergedRef = useMergeRefs([ref, refs.setFloating]);
    const childMergedRef = useMergeRefs([
        children
            .ref,
        refs.setReference,
    ]);
    if (!children ||
        children?.type === React.Fragment ||
        children === React.Fragment) {
        console.error('<Tooltip> children needs to be a single ReactElement and not: <React.Fragment/> | <></>');
        return null;
    }
    return (jsxs(Fragment, { children: [cloneElement(children, getReferenceProps({
                ref: childMergedRef,
            })), internalOpen && (jsx(Container, { children: jsxs("div", { ref: refs.setFloating, style: { ...floatingStyles, ...animationStyles, ...style }, role: 'tooltip', ...getFloatingProps({
                        className: clsx('fds-tooltip', inverted && 'fds-tooltip--inverted', className),
                        ref: mergedRef,
                        ...rest,
                    }), children: [content, jsx(FloatingArrow, { ref: arrowRef, context: context, className: 'fds-tooltip__arrow', height: ARROW_HEIGHT })] }) }))] }));
});
Tooltip.displayName = 'Tooltip';

export { Tooltip };
