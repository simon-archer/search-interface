'use client';
import { useMemo, Children, useState, isValidElement } from 'react';
import { ComboboxOption } from './Option/Option.js';
import ComboboxCustom from './Custom.js';

const isOption = (option) => !!option;
function isComboboxOption(child) {
    return isValidElement(child) && child.type === ComboboxOption;
}
function isComboboxCustom(child) {
    return isValidElement(child) && child.type === ComboboxCustom;
}
function isInteractiveComboboxCustom(child) {
    return isComboboxCustom(child) && child.props.interactive === true;
}
const INTERNAL_OPTION_PREFIX = 'internal-option-';
/**
 * We use this function to prefix the value of the options so we can make sure numbers as strings are not parsed as numbers in objects
 * @param value
 * @returns
 */
const prefix = (value) => {
    return INTERNAL_OPTION_PREFIX + value;
};
const removePrefix = (value) => {
    return value.slice(INTERNAL_OPTION_PREFIX.length);
};
function useCombobox({ children, inputValue, multiple, filter = (inputValue, option) => {
    return option.label.toLowerCase().startsWith(inputValue.toLowerCase());
}, initialValue, }) {
    const { optionsChildren, customIds, restChildren, interactiveChildren } = useMemo(() => {
        const allChildren = Children.toArray(children);
        const result = allChildren.reduce((acc, child) => {
            if (isComboboxOption(child)) {
                acc.optionsChildren.push(child);
            }
            else {
                acc.restChildren.push(child);
                if (isInteractiveComboboxCustom(child)) {
                    const childElement = child;
                    acc.interactiveChildren.push(childElement);
                    if (!childElement.props.id) {
                        throw new Error('If ComboboxCustom is interactive, it must have an id');
                    }
                    acc.customIds.push(childElement.props.id);
                }
            }
            return acc;
        }, {
            optionsChildren: [],
            customIds: [],
            restChildren: [],
            interactiveChildren: [],
        });
        return result;
    }, [children]);
    const options = useMemo(() => {
        const allOptions = {};
        optionsChildren.map((child) => {
            const props = child.props;
            let label = props.displayValue || '';
            if (!props.displayValue) {
                let childrenLabel = '';
                // go over children and find all strings
                Children.forEach(props.children, (child) => {
                    if (typeof child === 'string') {
                        childrenLabel += child;
                    }
                    else {
                        throw new Error('If ComboboxOption is not a string, it must have a displayValue prop');
                    }
                });
                label = childrenLabel;
            }
            allOptions[prefix(String(props.value))] = {
                value: String(props.value),
                label,
                displayValue: props.displayValue,
                description: props.description,
            };
        });
        return allOptions;
    }, [optionsChildren]);
    const preSelectedOptions = useMemo(() => (initialValue?.map((key) => {
        return prefix(key);
    }) || []).reduce((acc, value) => {
        const option = options[value];
        if (isOption(option)) {
            acc[value] = option;
        }
        return acc;
    }, {}), [initialValue, options]);
    const [selectedOptions, setSelectedOptions] = useState(preSelectedOptions);
    const { filteredOptions, filteredOptionsChildren } = useMemo(() => {
        const filteredOptions = [];
        const filteredOptionsChildren = Object.keys(options).map((option, index) => {
            /* If we have a selected value in single mode and the input matches an option, return all children */
            if (!multiple && Object.keys(selectedOptions).length === 1) {
                filteredOptions.push(option);
                return optionsChildren[index];
            }
            if (multiple && selectedOptions[option]) {
                filteredOptions.push(option);
                return optionsChildren[index];
            }
            if (filter(inputValue, options[option])) {
                filteredOptions.push(option);
                return optionsChildren[index];
            }
        });
        return { filteredOptions, filteredOptionsChildren };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [inputValue, multiple, options, optionsChildren, selectedOptions]);
    return {
        filteredOptionsChildren,
        filteredOptions,
        restChildren,
        options,
        customIds,
        selectedOptions,
        interactiveChildren,
        setSelectedOptions,
    };
}

export { useCombobox as default, isComboboxCustom, isComboboxOption, isInteractiveComboboxCustom, prefix, removePrefix };
