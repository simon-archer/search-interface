{"ast":null,"code":"'use client';\n\nimport { memo, notUndefined, approxEqual } from './utils.js';\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = rect => {\n    const {\n      width,\n      height\n    } = rect;\n    cb({\n      width: Math.round(width),\n      height: Math.round(height)\n    });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {};\n  }\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({\n          width: box.inlineSize,\n          height: box.blockSize\n        });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, {\n    box: \"border-box\"\n  });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n      return size;\n    }\n  }\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */new Map();\n    this.observer = /* @__PURE__ */(() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver(entries => {\n            entries.forEach(entry => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: target => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, {\n            box: \"border-box\"\n          });\n        },\n        unobserve: target => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = opts2 => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = sync => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(() => {\n      this.calculateRange();\n      return [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null];\n    }, isScrolling => {\n      this.notify(isScrolling);\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n      debug: () => this.options.debug,\n      initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]\n    });\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.maybeNotify();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          this.scrollAdjustments = 0;\n          if (this.scrollOffset === offset) {\n            return;\n          }\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId);\n            this.isScrollingTimeoutId = null;\n          }\n          this.isScrolling = true;\n          this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n          this.scrollOffset = offset;\n          this.maybeNotify();\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null;\n            this.isScrolling = false;\n            this.scrollDirection = null;\n            this.maybeNotify();\n          }, this.options.scrollingDelay);\n        }));\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey], (count, paddingStart, scrollMargin, getItemKey) => {\n      this.pendingMeasuredCacheIndexes = [];\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey\n      };\n    }, {\n      key: false\n    });\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */new Map();\n      const furthestMeasurements = /* @__PURE__ */new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(() => [this.memoOptions(), this.itemSizeCache], ({\n      count,\n      paddingStart,\n      scrollMargin,\n      getItemKey\n    }, itemSizeCache) => {\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n        const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n        const measuredSize = itemSizeCache.get(key);\n        const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane\n        };\n      }\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      }) : null;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return range === null ? [] : rangeExtractor({\n        ...range,\n        overscan,\n        count\n      });\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n      debug: () => this.options.debug\n    });\n    this.indexFromElement = node => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = node => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements()], (indexes, measurements) => {\n      const virtualItems = [];\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k];\n        const measurement = measurements[i];\n        virtualItems.push(measurement);\n      }\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n      debug: () => this.options.debug\n    });\n    this.getVirtualItemForOffset = offset => {\n      const measurements = this.getMeasurements();\n      return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, index => notUndefined(measurements[index]).start, offset)]);\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = notUndefined(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, {\n      align = \"start\",\n      behavior\n    } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, {\n      align: initialAlign = \"auto\",\n      behavior\n    } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, {\n        adjustments: void 0,\n        behavior\n      });\n      if (behavior !== \"smooth\" && this.isDynamicMode()) {\n        this.scrollToIndexTimeoutId = setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(this.options.getItemKey(index));\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, {\n                align,\n                behavior\n              });\n            }\n          } else {\n            this.scrollToIndex(index, {\n              align,\n              behavior\n            });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, {\n      behavior\n    } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map(m => m.end));\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, {\n        behavior,\n        adjustments\n      }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach(item => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = index => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex,\n    endIndex\n  };\n}\nexport { Virtualizer, approxEqual, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect };","map":{"version":3,"names":["memo","notUndefined","approxEqual","defaultKeyExtractor","index","defaultRangeExtractor","range","start","Math","max","startIndex","overscan","end","min","endIndex","count","arr","i","push","observeElementRect","instance","cb","element","scrollElement","handler","rect","width","height","round","getBoundingClientRect","ResizeObserver","observer","entries","entry","borderBoxSize","box","inlineSize","blockSize","observe","unobserve","observeElementOffset","options","horizontal","addEventListener","passive","removeEventListener","measureElement","size","elementScroll","offset","adjustments","behavior","_a","_b","toOffset","scrollTo","call","Virtualizer","constructor","opts","unsubs","isScrolling","isScrollingTimeoutId","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollDirection","scrollAdjustments","measureElementCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","key","value","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","onChange","initialRect","scrollMargin","gap","scrollingDelay","indexAttribute","initialMeasurementsCache","lanes","notify","sync","maybeNotify","calculateRange","process","env","NODE_ENV","initialDeps","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","scrollRect","clearTimeout","setTimeout","getSize","memoOptions","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","Array","from","values","sort","a","b","getMeasurements","length","slice","furthestMeasurement","measuredSize","estimateSize","outerSize","getIndexes","indexFromElement","node","attributeName","indexStr","getAttribute","console","warn","parseInt","item","isConnected","cached","delete","prevNode","measuredItemSize","resizeItem","itemSize","delta","info","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","findNearestBinarySearch","getOffsetForAlignment","align","scrollSizeProp","scrollSize","document","documentElement","maxOffset","getOffsetForIndex","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","elementInDOM","toOffset2","scrollBy","getTotalSize","map","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","getOffset"],"sources":["/Users/simondreyer/CascadeProjects/search-interface/node_modules/@digdir/designsystemet-react/dist/esm/node_modules/@tanstack/virtual-core/dist/esm/index.js"],"sourcesContent":["'use client';\nimport { memo, notUndefined, approxEqual } from './utils.js';\n\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {\n    };\n  }\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset) => {\n            this.scrollAdjustments = 0;\n            if (this.scrollOffset === offset) {\n              return;\n            }\n            if (this.isScrollingTimeoutId !== null) {\n              clearTimeout(this.isScrollingTimeoutId);\n              this.isScrollingTimeoutId = null;\n            }\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n            this.scrollOffset = offset;\n            this.maybeNotify();\n            this.isScrollingTimeoutId = setTimeout(() => {\n              this.isScrollingTimeoutId = null;\n              this.isScrolling = false;\n              this.scrollDirection = null;\n              this.maybeNotify();\n            }, this.options.scrollingDelay);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey\n      ],\n      (count, paddingStart, scrollMargin, getItemKey) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(\n      () => [this.memoOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = memo(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          ...range,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = notUndefined(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode()) {\n        this.scrollToIndexTimeoutId = setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\n\nexport { Virtualizer, approxEqual, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}