'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var floatingUi_react = require('../../node_modules/@floating-ui/react/dist/floating-ui.react.js');
var React = require('react');
var index = require('../../node_modules/@radix-ui/react-slot/dist/index.js');
var lite = require('../../node_modules/clsx/dist/lite.js');
var useScrollLock = require('./useScrollLock.js');
var useModalState = require('./useModalState.js');
var ModalRoot = require('./ModalRoot.js');

const ModalDialog = React.forwardRef(({ onInteractOutside, onClose, onBeforeClose, asChild, className, children, ...rest }, ref) => {
    const Component = asChild ? index.Slot : 'dialog';
    // This local ref is used to make sure the modal works without a ModalRoot
    const modalDialogRef = React.useRef(null);
    const { context } = floatingUi_react.useFloating();
    const modal = React.useContext(ModalRoot.ModalContext);
    const open = useModalState.useModalState(modalDialogRef);
    const { modalRef, setOpen } = modal;
    modal.closeModal = () => {
        if (onBeforeClose && onBeforeClose() === false)
            return;
        modalDialogRef.current?.close();
    };
    const mergedRefs = floatingUi_react.useMergeRefs([modalRef, ref, modalDialogRef]);
    useScrollLock.useScrollLock(modalDialogRef, 'fds-modal--lock-scroll');
    React.useEffect(() => {
        setOpen(open);
    }, [open, setOpen]);
    React.useEffect(() => {
        const modalEl = modalRef.current;
        const handleBackdropClick = (e) => {
            if (e.target === modalEl && onInteractOutside) {
                // Fix bug where if you select text spanning two divs it thinks you clicked outside
                if (window.getSelection()?.toString())
                    return;
                onInteractOutside?.();
            }
        };
        if (modalEl)
            modalEl.addEventListener('click', handleBackdropClick);
        return () => {
            if (modalEl) {
                modalEl.removeEventListener('click', handleBackdropClick);
            }
        };
    }, [onInteractOutside, modalRef, onBeforeClose, ref]);
    React.useEffect(() => {
        const modalEl = modalRef.current;
        const handleModalClose = () => {
            onClose?.();
        };
        if (modalEl)
            modalEl.addEventListener('close', handleModalClose);
        return () => {
            if (modalEl) {
                modalEl.removeEventListener('close', handleModalClose);
            }
        };
    }, [modalRef, onClose]);
    const onCancel = (e) => {
        if (onBeforeClose && onBeforeClose() === false) {
            e.preventDefault();
            return;
        }
        modalRef.current?.close();
    };
    return (jsxRuntime.jsx(Component, { ref: mergedRefs, className: lite.clsx('fds-modal', className), onCancel: onCancel, ...rest, children: open && (jsxRuntime.jsx(floatingUi_react.FloatingFocusManager, { context: context, children: jsxRuntime.jsx(jsxRuntime.Fragment, { children: children }) })) }));
});
ModalDialog.displayName = 'ModalDialog';

exports.ModalDialog = ModalDialog;
