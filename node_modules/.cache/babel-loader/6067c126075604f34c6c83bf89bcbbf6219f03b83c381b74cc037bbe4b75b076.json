{"ast":null,"code":"'use client';\n\nimport { memo, notUndefined, approxEqual } from './utils.js';\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = rect => {\n    const {\n      width,\n      height\n    } = rect;\n    cb({\n      width: Math.round(width),\n      height: Math.round(height)\n    });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {};\n  }\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({\n          width: box.inlineSize,\n          height: box.blockSize\n        });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, {\n    box: \"border-box\"\n  });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n      return size;\n    }\n  }\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst elementScroll = (offset, _ref, instance) => {\n  let {\n    adjustments = 0,\n    behavior\n  } = _ref;\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    var _this = this;\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */new Map();\n    this.observer = /* @__PURE__ */(() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver(entries => {\n            entries.forEach(entry => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: target => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, {\n            box: \"border-box\"\n          });\n        },\n        unobserve: target => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = opts2 => {\n      Object.entries(opts2).forEach(_ref2 => {\n        let [key, value] = _ref2;\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = sync => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(() => {\n      this.calculateRange();\n      return [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null];\n    }, isScrolling => {\n      this.notify(isScrolling);\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n      debug: () => this.options.debug,\n      initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]\n    });\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.maybeNotify();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          this.scrollAdjustments = 0;\n          if (this.scrollOffset === offset) {\n            return;\n          }\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId);\n            this.isScrollingTimeoutId = null;\n          }\n          this.isScrolling = true;\n          this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n          this.scrollOffset = offset;\n          this.maybeNotify();\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null;\n            this.isScrolling = false;\n            this.scrollDirection = null;\n            this.maybeNotify();\n          }, this.options.scrollingDelay);\n        }));\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey], (count, paddingStart, scrollMargin, getItemKey) => {\n      this.pendingMeasuredCacheIndexes = [];\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey\n      };\n    }, {\n      key: false\n    });\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */new Map();\n      const furthestMeasurements = /* @__PURE__ */new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(() => [this.memoOptions(), this.itemSizeCache], (_ref3, itemSizeCache) => {\n      let {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey\n      } = _ref3;\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n        const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n        const measuredSize = itemSizeCache.get(key);\n        const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane\n        };\n      }\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      }) : null;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return range === null ? [] : rangeExtractor({\n        ...range,\n        overscan,\n        count\n      });\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n      debug: () => this.options.debug\n    });\n    this.indexFromElement = node => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = node => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements()], (indexes, measurements) => {\n      const virtualItems = [];\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k];\n        const measurement = measurements[i];\n        virtualItems.push(measurement);\n      }\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n      debug: () => this.options.debug\n    });\n    this.getVirtualItemForOffset = offset => {\n      const measurements = this.getMeasurements();\n      return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, index => notUndefined(measurements[index]).start, offset)]);\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = function (index) {\n      let align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n      index = Math.max(0, Math.min(index, _this.options.count - 1));\n      const measurement = notUndefined(_this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [_this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n      return [_this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = function (toOffset) {\n      let {\n        align = \"start\",\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = function (index) {\n      let {\n        align: initialAlign = \"auto\",\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      index = Math.max(0, Math.min(index, _this.options.count - 1));\n      _this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      const [toOffset, align] = _this.getOffsetForIndex(index, initialAlign);\n      _this._scrollToOffset(toOffset, {\n        adjustments: void 0,\n        behavior\n      });\n      if (behavior !== \"smooth\" && _this.isDynamicMode()) {\n        _this.scrollToIndexTimeoutId = setTimeout(() => {\n          _this.scrollToIndexTimeoutId = null;\n          const elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));\n          if (elementInDOM) {\n            const [toOffset2] = _this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, _this.scrollOffset)) {\n              _this.scrollToIndex(index, {\n                align,\n                behavior\n              });\n            }\n          } else {\n            _this.scrollToIndex(index, {\n              align,\n              behavior\n            });\n          }\n        });\n      }\n    };\n    this.scrollBy = function (delta) {\n      let {\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n      _this._scrollToOffset(_this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(...measurements.slice(-this.options.lanes).map(m => m.end));\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, _ref4) => {\n      let {\n        adjustments,\n        behavior\n      } = _ref4;\n      this.options.scrollToFn(offset, {\n        behavior,\n        adjustments\n      }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach(item => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref5) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset\n  } = _ref5;\n  const count = measurements.length - 1;\n  const getOffset = index => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex,\n    endIndex\n  };\n}\nexport { Virtualizer, approxEqual, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect };","map":{"version":3,"names":["memo","notUndefined","approxEqual","defaultKeyExtractor","index","defaultRangeExtractor","range","start","Math","max","startIndex","overscan","end","min","endIndex","count","arr","i","push","observeElementRect","instance","cb","element","scrollElement","handler","rect","width","height","round","getBoundingClientRect","ResizeObserver","observer","entries","entry","borderBoxSize","box","inlineSize","blockSize","observe","unobserve","observeElementOffset","options","horizontal","addEventListener","passive","removeEventListener","measureElement","size","elementScroll","offset","_ref","adjustments","behavior","_a","_b","toOffset","scrollTo","call","Virtualizer","constructor","opts","_this","unsubs","isScrolling","isScrollingTimeoutId","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollDirection","scrollAdjustments","measureElementCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","_ref2","key","value","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","onChange","initialRect","scrollMargin","gap","scrollingDelay","indexAttribute","initialMeasurementsCache","lanes","notify","sync","maybeNotify","calculateRange","process","env","NODE_ENV","initialDeps","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","scrollRect","clearTimeout","setTimeout","getSize","memoOptions","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","Array","from","values","sort","a","b","getMeasurements","_ref3","length","slice","furthestMeasurement","measuredSize","estimateSize","outerSize","getIndexes","indexFromElement","node","attributeName","indexStr","getAttribute","console","warn","parseInt","item","isConnected","cached","delete","prevNode","measuredItemSize","resizeItem","itemSize","delta","info","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","findNearestBinarySearch","getOffsetForAlignment","align","scrollSizeProp","scrollSize","document","documentElement","maxOffset","getOffsetForIndex","arguments","undefined","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","elementInDOM","toOffset2","scrollBy","getTotalSize","map","_ref4","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","_ref5","getOffset"],"sources":["/Users/simondreyer/CascadeProjects/search-interface/node_modules/@digdir/designsystemet-react/dist/esm/node_modules/@tanstack/virtual-core/dist/esm/index.js"],"sourcesContent":["'use client';\nimport { memo, notUndefined, approxEqual } from './utils.js';\n\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(element.getBoundingClientRect());\n  if (typeof ResizeObserver === \"undefined\") {\n    return () => {\n    };\n  }\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0];\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n      const box = entry.borderBoxSize[0];\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize });\n        return;\n      }\n    }\n    handler(element.getBoundingClientRect());\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb(element[instance.options.horizontal ? \"scrollLeft\" : \"scrollTop\"]);\n  };\n  handler();\n  element.addEventListener(\"scroll\", handler, {\n    passive: true\n  });\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]\n  );\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.measureElementCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== \"undefined\") {\n          return _ro = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n              this._measureElement(entry.target, entry);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.disconnect();\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\")\n          delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        scrollingDelay: 150,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      this.measureElementCache.forEach(this.observer.observe);\n      return () => {\n        this.observer.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset) => {\n            this.scrollAdjustments = 0;\n            if (this.scrollOffset === offset) {\n              return;\n            }\n            if (this.isScrollingTimeoutId !== null) {\n              clearTimeout(this.isScrollingTimeoutId);\n              this.isScrollingTimeoutId = null;\n            }\n            this.isScrolling = true;\n            this.scrollDirection = this.scrollOffset < offset ? \"forward\" : \"backward\";\n            this.scrollOffset = offset;\n            this.maybeNotify();\n            this.isScrollingTimeoutId = setTimeout(() => {\n              this.isScrollingTimeoutId = null;\n              this.isScrolling = false;\n              this.scrollDirection = null;\n              this.maybeNotify();\n            }, this.options.scrollingDelay);\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.memoOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey\n      ],\n      (count, paddingStart, scrollMargin, getItemKey) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurements = memo(\n      () => [this.memoOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n      (measurements, outerSize, scrollOffset) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getIndexes = memo(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (rangeExtractor, range, overscan, count) => {\n        return range === null ? [] : rangeExtractor({\n          ...range,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const item = this.measurementsCache[this.indexFromElement(node)];\n      if (!item || !node.isConnected) {\n        this.measureElementCache.forEach((cached, key) => {\n          if (cached === node) {\n            this.observer.unobserve(node);\n            this.measureElementCache.delete(key);\n          }\n        });\n        return;\n      }\n      const prevNode = this.measureElementCache.get(item.key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.measureElementCache.set(item.key, node);\n      }\n      const measuredItemSize = this.options.measureElement(node, entry, this);\n      this.resizeItem(item, measuredItemSize);\n    };\n    this.resizeItem = (item, size) => {\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align) => {\n      const size = this.getSize();\n      if (align === \"auto\") {\n        if (toOffset <= this.scrollOffset) {\n          align = \"start\";\n        } else if (toOffset >= this.scrollOffset + size) {\n          align = \"end\";\n        } else {\n          align = \"start\";\n        }\n      }\n      if (align === \"start\") {\n        toOffset = toOffset;\n      } else if (align === \"end\") {\n        toOffset = toOffset - size;\n      } else if (align === \"center\") {\n        toOffset = toOffset - size / 2;\n      }\n      const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n      const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n      const maxOffset = scrollSize - this.getSize();\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const measurement = notUndefined(this.getMeasurements()[index]);\n      if (align === \"auto\") {\n        if (measurement.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (measurement.start <= this.scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [this.scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? measurement.end + this.options.scrollPaddingEnd : measurement.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(toOffset, align), align];\n    };\n    this.isDynamicMode = () => this.measureElementCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null) {\n        clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const [toOffset, align] = this.getOffsetForIndex(index, initialAlign);\n      this._scrollToOffset(toOffset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode()) {\n        this.scrollToIndexTimeoutId = setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.measureElementCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [toOffset2] = this.getOffsetForIndex(index, align);\n            if (!approxEqual(toOffset2, this.scrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.scrollOffset + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else {\n        end = this.options.lanes === 1 ? ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0 : Math.max(\n          ...measurements.slice(-this.options.lanes).map((m) => m.end)\n        );\n      }\n      return end - this.options.scrollMargin + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.measurementsCache = this.options.initialMeasurementsCache;\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size);\n    });\n    this.maybeNotify();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset\n}) {\n  const count = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return { startIndex, endIndex };\n}\n\nexport { Virtualizer, approxEqual, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}