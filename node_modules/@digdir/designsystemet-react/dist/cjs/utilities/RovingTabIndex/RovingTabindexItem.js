'use client';
'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var floatingUi_react = require('../../node_modules/@floating-ui/react/dist/floating-ui.react.js');
var index = require('../../node_modules/@radix-ui/react-slot/dist/index.js');
var useRovingTabindex = require('./useRovingTabindex.js');

/** Get the next focusable RovingTabindexItem */
function getNextFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === items.length - 1 ? 0 : currIndex + 1);
}
/** Get the previous focusable RovingTabindexItem */
function getPrevFocusableValue(items, value) {
    const currIndex = items.findIndex((item) => item.value === value);
    return items.at(currIndex === 0 ? -1 : currIndex - 1);
}
const RovingTabindexItem = React.forwardRef(({ value, asChild, ...rest }, ref) => {
    const Component = asChild ? index.Slot : 'div';
    const focusValue = value ?? (typeof rest.children == 'string' ? rest.children : '');
    const { getOrderedItems, getRovingProps } = useRovingTabindex.useRovingTabindex(focusValue);
    const rovingProps = getRovingProps({
        onKeyDown: (e) => {
            rest?.onKeyDown?.(e);
            const items = getOrderedItems();
            let nextItem;
            if (e.key === 'ArrowRight') {
                nextItem = getNextFocusableValue(items, focusValue);
            }
            if (e.key === 'ArrowLeft') {
                nextItem = getPrevFocusableValue(items, focusValue);
            }
            nextItem?.element.focus();
        },
    });
    const mergedRefs = floatingUi_react.useMergeRefs([ref, rovingProps.ref]);
    return (jsxRuntime.jsx(Component, { ...rest, ...rovingProps, ref: mergedRefs, children: rest.children }));
});

exports.RovingTabindexItem = RovingTabindexItem;
exports.getNextFocusableValue = getNextFocusableValue;
exports.getPrevFocusableValue = getPrevFocusableValue;
