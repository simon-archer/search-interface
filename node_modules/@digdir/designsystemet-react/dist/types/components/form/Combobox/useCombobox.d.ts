import type { ReactNode, ReactElement } from 'react';
import type { ComboboxOptionProps } from './Option/Option';
import type { ComboboxProps } from './Combobox';
import type { ComboboxCustomProps } from './Custom';
export type UseComboboxProps = {
    children: ReactNode;
    inputValue: string;
    multiple: boolean;
    filter?: NonNullable<ComboboxProps['filter']>;
    initialValue?: string[];
};
export type Option = {
    value: string;
    label: string;
    displayValue?: string;
    description?: string;
};
export declare function isComboboxOption(child: ReactNode): child is ReactElement<ComboboxOptionProps>;
export declare function isComboboxCustom(child: ReactNode): child is ReactElement<ComboboxCustomProps>;
export declare function isInteractiveComboboxCustom(child: ReactNode): child is ReactElement<ComboboxCustomProps>;
/**
 * We use this function to prefix the value of the options so we can make sure numbers as strings are not parsed as numbers in objects
 * @param value
 * @returns
 */
export declare const prefix: (value?: string) => string;
export declare const removePrefix: (value: string) => string;
export default function useCombobox({ children, inputValue, multiple, filter, initialValue, }: UseComboboxProps): {
    filteredOptionsChildren: (ReactElement<ComboboxOptionProps, string | import("react").JSXElementConstructor<any>> | undefined)[];
    filteredOptions: string[];
    restChildren: ReactNode[];
    options: {
        [key: string]: Option;
    };
    customIds: string[];
    selectedOptions: {
        [key: string]: Option;
    };
    interactiveChildren: ReactElement<ComboboxCustomProps, string | import("react").JSXElementConstructor<any>>[];
    setSelectedOptions: import("react").Dispatch<import("react").SetStateAction<{
        [key: string]: Option;
    }>>;
};
//# sourceMappingURL=useCombobox.d.ts.map